<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Metainspector by jaimeiniesta</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Metainspector</h1>
        <h2>Ruby gem for web scraping purposes.</h2>
        <a href="https://github.com/jaimeiniesta/metainspector" class="button"><small>View project on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>
<a id="metainspector--" class="anchor" href="#metainspector--" aria-hidden="true"><span class="octicon octicon-link"></span></a>MetaInspector <a href="http://travis-ci.org/jaimeiniesta/metainspector"><img src="https://secure.travis-ci.org/jaimeiniesta/metainspector.png" alt="Build Status"></a> <a href="https://gemnasium.com/jaimeiniesta/metainspector"><img src="https://gemnasium.com/jaimeiniesta/metainspector.png" alt="Dependency Status"></a>
</h1>

<p>MetaInspector is a gem for web scraping purposes.</p>

<p>You give it an URL, and it lets you easily get its title, links, images, charset, description, keywords, meta tags...</p>

<h2>
<a id="see-it-in-action" class="anchor" href="#see-it-in-action" aria-hidden="true"><span class="octicon octicon-link"></span></a>See it in action!</h2>

<p>You can try MetaInspector live at this little demo: <a href="https://metainspectordemo.herokuapp.com">https://metainspectordemo.herokuapp.com</a></p>

<h2>
<a id="changes-in-40" class="anchor" href="#changes-in-40" aria-hidden="true"><span class="octicon octicon-link"></span></a>Changes in 4.0</h2>

<ul>
<li>The links API has been changed, now instead of <code>page.links</code>, <code>page.internal_links</code> and <code>page.external_links</code> we have:</li>
</ul>

<div class="highlight highlight-ruby"><pre>page.links.raw      <span class="pl-c"># Returns all links found, unprocessed</span>
page.links.all      <span class="pl-c"># Returns all links found, unrelavitized and absolutified</span>
page.links.http     <span class="pl-c"># Returns all HTTP links found</span>
page.links.non_http <span class="pl-c"># Returns all non-HTTP links found</span>
page.links.internal <span class="pl-c"># Returns all internal HTTP links found</span>
page.links.external <span class="pl-c"># Returns all external HTTP links found</span></pre></div>

<ul>
<li><p>The images API has been changed, now instead of <code>page.image</code> we have <code>page.images.best</code>, and instead of <code>page.favicon</code> we have <code>page.images.favicon</code>.</p></li>
<li><p>Now <code>page.image</code> will return the first image in <code>page.images</code> if no OG or Twitter image found, instead of returning <code>nil</code>.</p></li>
<li><p>You can now specify 2 different timeouts, <code>connection_timeout</code> and <code>read_timeout</code>, instead of the previous single <code>timeout</code>.</p></li>
</ul>

<h2>
<a id="changes-in-30" class="anchor" href="#changes-in-30" aria-hidden="true"><span class="octicon octicon-link"></span></a>Changes in 3.0</h2>

<ul>
<li>The redirect API has been changed, now the <code>:allow_redirections</code> option will expect only a boolean, which by default is <code>true</code>. That is, no more specifying <code>:safe</code>, <code>:unsafe</code> or <code>:all</code>.</li>
<li>We've dropped support for Ruby &lt; 2.</li>
</ul>

<p>Also, we've introduced a new feature:</p>

<ul>
<li>Persist cookies across redirects. Now MetaInspector will include the received cookies when following redirects. This fixes some cases where a redirect would fail, sometimes caught in a redirection loop.</li>
</ul>

<h2>
<a id="installation" class="anchor" href="#installation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Installation</h2>

<p>Install the gem from RubyGems:</p>

<pre><code>gem install metainspector
</code></pre>

<p>If you're using it on a Rails application, just add it to your Gemfile and run <code>bundle install</code></p>

<pre><code>gem 'metainspector'
</code></pre>

<p>This gem is tested on Ruby versions 2.0.0 and 2.1.3.</p>

<h2>
<a id="usage" class="anchor" href="#usage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Usage</h2>

<p>Initialize a MetaInspector instance for an URL, like this:</p>

<pre><code>page = MetaInspector.new('http://sitevalidator.com')
</code></pre>

<p>If you don't include the scheme on the URL, http:// will be used by default:</p>

<pre><code>page = MetaInspector.new('sitevalidator.com')
</code></pre>

<p>You can also include the html which will be used as the document to scrape:</p>

<pre><code>page = MetaInspector.new("http://sitevalidator.com", :document =&gt; "&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello From Passed Html&lt;/title&gt;&lt;a href='/hello'&gt;Hello link&lt;/a&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;")
</code></pre>

<h2>
<a id="accessing-response-status-and-headers" class="anchor" href="#accessing-response-status-and-headers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Accessing response status and headers</h2>

<p>You can check the status and headers from the response like this:</p>

<div class="highlight highlight-ruby"><pre>page.response.status  <span class="pl-c"># 200</span>
page.response.headers <span class="pl-c"># { "server"=&gt;"nginx", "content-type"=&gt;"text/html; charset=utf-8", "cache-control"=&gt;"must-revalidate, private, max-age=0", ... }</span></pre></div>

<h2>
<a id="accessing-scraped-data" class="anchor" href="#accessing-scraped-data" aria-hidden="true"><span class="octicon octicon-link"></span></a>Accessing scraped data</h2>

<p>You can see the scraped data like this:</p>

<pre><code>page.url                 # URL of the page
page.scheme              # Scheme of the page (http, https)
page.host                # Hostname of the page (like, sitevalidator.com, without the scheme)
page.root_url            # Root url (scheme + host, like http://sitevalidator.com/)
page.title               # title of the page, as string
page.links.raw           # every link found, unprocessed
page.links.all           # every link found on the page as an absolute URL
page.links.http          # every HTTP link found
page.links.non_http      # every non-HTTP link found
page.links.internal      # every internal link found on the page as an absolute URL
page.links.external      # every external link found on the page as an absolute URL
page.meta['keywords']    # meta keywords, as string
page.meta['description'] # meta description, as string
page.description         # returns the meta description, or the first long paragraph if no meta description is found
page.images              # enumerable collection, with every img found on the page as an absolute URL
page.images.best         # Most relevant image, if defined with the og:image or twitter:image metatags. Fallback to the first page.images array element
page.images.favicon      # absolute URL to the favicon
page.feed                # Get rss or atom links in meta data fields as array
page.charset             # UTF-8
page.content_type        # content-type returned by the server when the url was requested
</code></pre>

<h2>
<a id="meta-tags" class="anchor" href="#meta-tags" aria-hidden="true"><span class="octicon octicon-link"></span></a>Meta tags</h2>

<p>When it comes to meta tags, you have several options:</p>

<pre><code>page.meta_tags          # Gives you all the meta tags by type:
                        # (meta name, meta http-equiv, meta property and meta charset)
                        # As meta tags can be repeated (in the case of 'og:image', for example),
                        # the values returned will be arrays
                        #
                        # For example:
                        #
                        # {
                            'name' =&gt; {
                                        'keywords'       =&gt; ['one, two, three'],
                                        'description'    =&gt; ['the description'],
                                        'author'         =&gt; ['Joe Sample'],
                                        'robots'         =&gt; ['index,follow'],
                                        'revisit'        =&gt; ['15 days'],
                                        'dc.date.issued' =&gt; ['2011-09-15']
                                       },

                            'http-equiv' =&gt; {
                                              'content-type'        =&gt; ['text/html; charset=UTF-8'],
                                              'content-style-type'  =&gt; ['text/css']
                                            },

                            'property' =&gt; {
                                            'og:title'        =&gt; ['An OG title'],
                                            'og:type'         =&gt; ['website'],
                                            'og:url'          =&gt; ['http://example.com/meta-tags'],
                                            'og:image'        =&gt; ['http://example.com/rock.jpg',
                                                                  'http://example.com/rock2.jpg',
                                                                  'http://example.com/rock3.jpg'],
                                            'og:image:width'  =&gt; ['300'],
                                            'og:image:height' =&gt; ['300', '1000']
                                          },

                            'charset' =&gt; ['UTF-8']
                          }
</code></pre>

<p>As this method returns a hash, you can also take only the key that you need, like in:</p>

<pre><code>page.meta_tags['property']  # Returns:
                            # {
                            #   'og:title'        =&gt; ['An OG title'],
                            #   'og:type'         =&gt; ['website'],
                            #   'og:url'          =&gt; ['http://example.com/meta-tags'],
                            #   'og:image'        =&gt; ['http://example.com/rock.jpg',
                            #                         'http://example.com/rock2.jpg',
                            #                         'http://example.com/rock3.jpg'],
                            #   'og:image:width'  =&gt; ['300'],
                            #   'og:image:height' =&gt; ['300', '1000']
                            # }
</code></pre>

<p>In most cases you will only be interested in the first occurrence of a meta tag, so you can
use the singular form of that method:</p>

<pre><code>page.meta_tag['name']  # Returns:
                       # {
                       #   'keywords'       =&gt; 'one, two, three',
                       #   'description'    =&gt; 'the description',
                       #   'author'         =&gt; 'Joe Sample',
                       #   'robots'         =&gt; 'index,follow',
                       #   'revisit'        =&gt; '15 days',
                       #   'dc.date.issued' =&gt; '2011-09-15'
                       #  }
</code></pre>

<p>Or, as this is also a hash:</p>

<pre><code>page.meta_tag['name']['keywords']    # Returns 'one, two, three'
</code></pre>

<p>And finally, you can use the shorter <code>meta</code> method that will merge the different keys so you have
a simpler hash:</p>

<pre><code>page.meta       # Returns:
                #
                # {
                #     'keywords'            =&gt; 'one, two, three',
                #     'description'         =&gt; 'the description',
                #     'author'              =&gt; 'Joe Sample',
                #     'robots'              =&gt; 'index,follow',
                #     'revisit'             =&gt; '15 days',
                #     'dc.date.issued'      =&gt; '2011-09-15',
                #     'content-type'        =&gt; 'text/html; charset=UTF-8',
                #     'content-style-type'  =&gt; 'text/css',
                #     'og:title'            =&gt; 'An OG title',
                #     'og:type'             =&gt; 'website',
                #     'og:url'              =&gt; 'http://example.com/meta-tags',
                #     'og:image'            =&gt; 'http://example.com/rock.jpg',
                #     'og:image:width'      =&gt; '300',
                #     'og:image:height'     =&gt; '300',
                #     'charset'             =&gt; 'UTF-8'
                #   }
</code></pre>

<p>This way, you can get most meta tags just like that:</p>

<pre><code>page.meta['author']     # Returns "Joe Sample"
</code></pre>

<p>Please be aware that all keys are converted to downcase, so it's <code>'dc.date.issued'</code> and not <code>'DC.date.issued'</code>.</p>

<h2>
<a id="other-representations" class="anchor" href="#other-representations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Other representations</h2>

<p>You can also access most of the scraped data as a hash:</p>

<pre><code>page.to_hash  # { "url"   =&gt; "http://sitevalidator.com",
                  "title" =&gt; "MarkupValidator :: site-wide markup validation tool", ... }
</code></pre>

<p>The original document is accessible from:</p>

<pre><code>page.to_s         # A String with the contents of the HTML document
</code></pre>

<p>And the full scraped document is accessible from:</p>

<pre><code>page.parsed  # Nokogiri doc that you can use it to get any element from the page
</code></pre>

<h2>
<a id="options" class="anchor" href="#options" aria-hidden="true"><span class="octicon octicon-link"></span></a>Options</h2>

<h3>
<a id="timeout--retries" class="anchor" href="#timeout--retries" aria-hidden="true"><span class="octicon octicon-link"></span></a>Timeout &amp; Retries</h3>

<p>You can specify 2 different timeouts when requesting a page:</p>

<ul>
<li>
<code>connection_timeout</code> sets the maximum number of seconds to wait to get a connection to the page.</li>
<li>
<code>read_timeout</code> sets the maximum number of seconds to wait to read the page, once connected.</li>
</ul>

<p>Both timeouts default to 20 seconds each.</p>

<p>You can also specify the number of <code>retries</code>, which defaults to 3.</p>

<p>For example, this will time out after 10 seconds waiting for a connection, or after 5 seconds waiting
to read its contents, and will retry 4 times:</p>

<div class="highlight highlight-ruby"><pre>page <span class="pl-k">=</span> <span class="pl-s3">MetaInspector</span>.<span class="pl-k">new</span>(<span class="pl-s1"><span class="pl-pds">'</span>www.google<span class="pl-pds">'</span></span>, <span class="pl-c1">:connection_timeout</span> =&gt; <span class="pl-c1">10</span>, <span class="pl-c1">:read_timeout</span> =&gt; <span class="pl-c1">5</span>, <span class="pl-c1">:retries</span> =&gt; <span class="pl-c1">4</span>)</pre></div>

<p>If MetaInspector fails to fetch the page after it has exhausted its retries,
it will raise <code>Faraday::TimeoutError</code>, which you can rescue in your
application code.</p>

<div class="highlight highlight-ruby"><pre><span class="pl-k">begin</span>
  page <span class="pl-k">=</span> <span class="pl-s3">MetaInspector</span>.<span class="pl-k">new</span>(url)
<span class="pl-k">rescue</span> <span class="pl-s3">Faraday</span>::<span class="pl-vo">TimeoutError</span>
  enqueue_for_future_fetch_attempt(url)
  render_simple(url)
<span class="pl-k">else</span>
  render_rich(page)
<span class="pl-k">end</span></pre></div>

<h3>
<a id="redirections" class="anchor" href="#redirections" aria-hidden="true"><span class="octicon octicon-link"></span></a>Redirections</h3>

<p>By default, MetaInspector will follow redirects (up to a limit of 10).</p>

<p>If you want to disallow redirects, you can do it like this:</p>

<pre><code>page = MetaInspector.new('facebook.com', :allow_redirections =&gt; false)
</code></pre>

<h3>
<a id="headers" class="anchor" href="#headers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Headers</h3>

<p>By default, the following headers are set:</p>

<pre><code>{'User-Agent' =&gt; "MetaInspector/#{MetaInspector::VERSION} (+https://github.com/jaimeiniesta/metainspector)"}
</code></pre>

<p>If you want to set custom headers then use the <code>headers</code> option:</p>

<pre><code> # Set the User-Agent header
 page = MetaInspector.new('example.com', :headers =&gt; {'User-Agent' =&gt; 'My custom User-Agent'})
</code></pre>

<h3>
<a id="html-content-only" class="anchor" href="#html-content-only" aria-hidden="true"><span class="octicon octicon-link"></span></a>HTML Content Only</h3>

<p>MetaInspector will try to parse all URLs by default. If you want to raise an exception when trying to parse a non-html URL (one that has a content-type different than text/html), you can state it like this:</p>

<pre><code>page = MetaInspector.new('sitevalidator.com', :html_content_only =&gt; true)
</code></pre>

<p>This is useful when using MetaInspector on web spidering. Although on the initial URL you'll probably have an HTML URL, following links you may find yourself trying to parse non-html URLs.</p>

<pre><code>page = MetaInspector.new('http://example.com/image.png')
page.content_type  # "image/png"
page.description   # will returned a garbled string

page = MetaInspector.new('http://example.com/image.png', :html_content_only =&gt; true)
page.content_type  # "image/png"
page.description   # raises an exception
</code></pre>

<h2>
<a id="exception-handling" class="anchor" href="#exception-handling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Exception handling</h2>

<p>By default, MetaInspector will raise the exceptions found. We think that this is the safest default: in case the URL you're trying to scrape is unreachable, you should clearly be notified, and treat the exception as needed in your app.</p>

<p>However, if you prefer you can also set the <code>warn_level: :warn</code> option, so that exceptions found will just be warned on the standard output, instead of being raised.</p>

<p>You can also set the <code>warn_level: :store</code> option so that exceptions found will be silenced, and left for you to inspect on <code>page.exceptions</code>. You can also ask for <code>page.ok?</code>, wich will return <code>true</code> if no exceptions are stored.</p>

<p>You should avoid using the <code>:store</code> option, or use it wisely, as silencing errors can be problematic, it's always better to face the errors and treat them accordingly.</p>

<h2>
<a id="examples" class="anchor" href="#examples" aria-hidden="true"><span class="octicon octicon-link"></span></a>Examples</h2>

<p>You can find some sample scripts on the <code>examples</code> folder, including a basic scraping and a spider that will follow external links using a queue. What follows is an example of use from irb:</p>

<pre><code>$ irb
&gt;&gt; require 'metainspector'
=&gt; true

&gt;&gt; page = MetaInspector.new('http://sitevalidator.com')
=&gt; #&lt;MetaInspector:0x11330c0 @url="http://sitevalidator.com"&gt;

&gt;&gt; page.title
=&gt; "MarkupValidator :: site-wide markup validation tool"

&gt;&gt; page.meta['description']
=&gt; "Site-wide markup validation tool. Validate the markup of your whole site with just one click."

&gt;&gt; page.meta['keywords']
=&gt; "html, markup, validation, validator, tool, w3c, development, standards, free"

&gt;&gt; page.links.size
=&gt; 15

&gt;&gt; page.links[4]
=&gt; "/plans-and-pricing"
</code></pre>

<h2>
<a id="zomg-fork-thank-you" class="anchor" href="#zomg-fork-thank-you" aria-hidden="true"><span class="octicon octicon-link"></span></a>ZOMG Fork! Thank you!</h2>

<p>You're welcome to fork this project and send pull requests. Just remember to include specs.</p>

<p>Thanks to all the contributors:</p>

<p><a href="https://github.com/jaimeiniesta/metainspector/graphs/contributors">https://github.com/jaimeiniesta/metainspector/graphs/contributors</a></p>

<p>You are more than welcome to come chat with us on our <a href="https://gitter.im/jaimeiniesta/metainspector">Gitter room</a> and <a href="https://groups.google.com/forum/#!forum/metainspector">Google group</a>.</p>

<h2>
<a id="related-projects" class="anchor" href="#related-projects" aria-hidden="true"><span class="octicon octicon-link"></span></a>Related projects</h2>

<ul>
<li>
<a href="https://github.com/fern4lvarez/go-metainspector">go-metainspector</a>, a port of MetaInspector for Go.</li>
<li>
<a href="https://github.com/gabceb/node-metainspector">Node-MetaInspector</a>, a port of MetaInspector for Node.</li>
</ul>

<h2>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span class="octicon octicon-link"></span></a>License</h2>

<p>MetaInspector is released under the <a href="MIT-LICENSE">MIT license</a>.</p>
        </section>

        <aside id="sidebar">
          <a href="https://github.com/jaimeiniesta/metainspector/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/jaimeiniesta/metainspector/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/jaimeiniesta/metainspector"></a> is maintained by <a href="https://github.com/jaimeiniesta">jaimeiniesta</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>
